load "gmsh";
load "iovtk";
load "UMFPACK64";
load "isoline";
load "Element_P3";

real endsim=52;
real endrelaxation=0.2; // n steps before swapping to phase field main
bool printScreen=true;
int screenStep = 5;
real equilibraterho=1; // use lower rho surface tension at the beginning of simulation

string parstr = "";
string dirstr = "";
if (ARGV.n > 3)
{
    parstr = "-" + ARGV[2] + "-" + ARGV[3] + "-" + ARGV[4];
    dirstr =  ARGV[2] + "-" + ARGV[3] + "-" + ARGV[4] + "/";
    printScreen = false;
}

verbosity=0;
int PrintStep=50;
bool doPrint=true;
bool doTimespan=false;
int timePrint=100;
bool printinterface=false;
bool PrintEnergy=true;
string foldern = "images/" + dirstr + "phirho-images/";
string folderint1 = "images/" + dirstr + "interface1/";
string folderint2 = "images/" + dirstr + "interface2/";
string folderphi = "images/" + dirstr + "phi-images/";
string folderrho = "images/" + dirstr + "rho-images/";
// string folderrhotwo = "images/" + dirstr + "rhotwo-images/";
string commandstart = "mkdir images";
string command0 = "mkdir images/" + dirstr;
string command1 = "mkdir images/" + dirstr + "phirho-images";
string command2 = "mkdir images/" + dirstr + "interface1";
string command3 = "mkdir images/" + dirstr + "interface2";
string command4 = "mkdir images/" + dirstr + "phi-images";
string command5 = "mkdir images/" + dirstr + "rho-images";
// string command6 = "mkdir images/" + dirstr + "rhotwo-images";

bool makeData = true;

if (dirstr == "")
{
    dirstr = "data/";
}

string datafolder = "model-output/" + dirstr;
string datacommand1 = "mkdir model-output";
string datacommand2 = "mkdir model-output/" + dirstr;

if (makeData)
{
    system(datacommand1);
    system(datacommand2);
}


if (doPrint)
{
    system(commandstart);
    system(command0);
    if (printinterface)
    {
        system(command2);
        system(command3);
    }
    system(command1);
    system(command4);
    system(command5);
    // system(command6);
}
   

// -------------------------------------------------------------------------------------------------------------------------------------
// Mesh and grid

real xmin =  -2;
real xmax =  2;
real ymin =  0;
real ymax =  6;

// Mesh resolution
int  n     = 2; // Number of segments per unit length
real refI  = 14; // Refinement factor for the interface
real mGrw  = 1.2;  // Growth rate of the mesh elements
int  dref  = 10; // Number of time-steps between mesh adaption

mesh Th = square((xmax-xmin)*n,(ymax-ymin)*n,[xmin+(xmax-xmin)*x,ymin+(ymax-ymin)*y]);

// -------------------------------------------------------------------------------------------------------------------------------------
// Fields
fespace Vhfield (Th,P2,periodic=[[2,y],[4,y],[1,x],[3,x]]);
// -------------------------------------------------------------------------------------------------------------------------------------




Vhfield c1;
Vhfield c2;
Vhfield c1old;
Vhfield c2old;
Vhfield v;
Vhfield w;

real dt = 0.01;
real sig12=10;
real sig23=10;
real sig13=10;
real k1 = sig12 + sig13 - sig23;
real k2 = sig12 + sig23 - sig13;
real k3 = sig13 + sig23 - sig12;
real epssq =0.0002;
real eta=1;
real lmda = 120;

real c1Area = 0;
real c2Area = 0;
real c3Area = 0;

real A0c1 = 1;
real A0c2 = 1;
real A0c3 = 1;

// Is this the correct way to do this?? I'm not sure.
real TotalArea = (ymax-ymin) * (xmax-xmin);

macro GetArea()

    c1Area = int2d(Th)(c1^2 * (3 - 2*c1));
    c2Area = int2d(Th)(c2^2 * (3 - 2*c2));

    c3Area =  TotalArea - c1Area - c2Area

// EOM


problem SolveOne(c1, v, master=0, solver=sparsesolver)
    =int2d(Th)(v * (c1)/dt)

    // double well terms
    + int2d(Th)(1/eta * v * sig12 * c1 * c2^2 )
    + int2d(Th)(1/eta * v * sig13 * ( c1  - 3*c1*c1old - 2*c1*c2 + 2*c1*c1old^2 + c1*c2^2 + 3*c1*c1old*c2))
    + int2d(Th)(1/eta * v * sig23 * ( c1*c2^2 ))
    + int2d(Th)(1/eta * v * sig23 * ( - c2^2 + c2^3 ))

    // gradient energy terms
    + int2d(Th) (1/eta * epssq * k1 * (dx(c1) * dx(v) + dy(c1) * dy(v)))
    + int2d(Th) (1/eta * epssq * k3 * (dx(c1) * dx(v) + dy(c1) * dy(v)))
    + int2d(Th) (1/eta * epssq * k3 * (dx(c2) * dx(v) + dy(c2) * dy(v)))

    // volume constraints:
    + int2d(Th) (1/eta * ( v * lmda *(c1Area-A0c1)*c1*(1-c1old)))

    // --- terms that do NOT contain c1 --------------------- (→ right-hand side)
    + int2d(Th)( (1/eta) * v * lmda * (c3Area - A0c3) * (c1old + c2) )
    - int2d(Th)( (1/eta) * v * lmda * (c3Area - A0c3) * c2 * (c1old + c2) )

    // --- term that DOES contain c1 ------------------------ (→ left-hand side)
    - int2d(Th)( (1/eta) * v * lmda * (c3Area - A0c3) * c1 * (c1old + c2) )


    - int2d(Th)(v * c1old/dt);




problem SolveTwo(c2, w, master=0, solver=sparsesolver)
    =int2d(Th)(w * (c2)/dt)

    // double well terms
    + int2d(Th)(1/eta * w * sig12 * c2 * c1^2 )
    + int2d(Th)(1/eta * w * sig23 * ( c2  - 3*c2*c2old - 2*c2*c1 + 2*c2*c2old^2 + c2*c1^2 + 3*c2*c2old*c1))
    + int2d(Th)(1/eta * w * sig13 * ( c2*c1^2 ))
    + int2d(Th)(1/eta * w * sig13 * ( c1^3- c1^2  ))

    // gradient energy terms
    + int2d(Th) (1/eta * epssq * k1 * (dx(c2) * dx(w) + dy(c2) * dy(w)))
    + int2d(Th) (1/eta * epssq * k3 * (dx(c2) * dx(w) + dy(c2) * dy(w)))
    + int2d(Th) (1/eta * epssq * k3 * (dx(c1) * dx(w) + dy(c1) * dy(w)))

    // volume constraints:
    + int2d(Th) (1/eta * ( w * lmda *(c2Area-A0c2)*c2*(1-c2old)))


    + int2d(Th) (1/eta * ( w * lmda *(c3Area-A0c3)*(c2old+c1)))
    - int2d(Th) (1/eta * ( w * lmda *(c3Area-A0c3)*c2*(c2old+c1)))
    - int2d(Th) (1/eta * ( w * lmda *(c3Area-A0c3)*c1*(c2old+c1)))

    - int2d(Th)(w * c2old/dt);




macro getAdaptMesh()
Th = adaptmesh(Th,interfacemesh,hmin=1.0/(n*refI),hmax=1.0/n,iso=true,ratio=mGrw,err=0.01,nbvx=5e4,periodic=[[2,y],[4,y],[1,x],[3,x]]);
w=0;
v=0;
// EOM

Vhfield interfacemesh;
macro MakeMesh()
interfacemesh = c1 - c2;
// EOM


real dR = 0.6;  // Radius
real dRrho = 0.4;  // Radius
real dxc= 0.0;  // x coordinate
real dyc= 3;  // y coordinate, 0.2 is start above gorund
real DropTh = 0.1;  // Drop thickness
real Lx = dR;  // x half-extent
real Ly = dR;  // y half-extent

func initc1 = 0.5* (1.-tanh(( max(abs((x - dxc) / Lx), abs((y - 4) / Ly)) - 1.0 )/ DropTh));

// func initc1 = -tanh(( max(abs((x - dxc) / Lx), abs((y - dyc) / Ly)) - 1.0 )/ DropTh);

// func initc2 = 0.5 * (1.0- tanh(( max(abs((x - 0) / Lx), abs((y - 3) / Ly)) - 1.0 )/ DropTh));

func initc2 = 0.5* (1.-tanh(( max(abs((x - dxc) / Lx), abs((y - 2.9) / Ly)) - 1.0 )/ DropTh));
// func initc2 = 0.5 * (1.0- tanh((abs(y-3)-1)/ DropTh));





// plot(c1, wait=true, fill=true, value=1);
// plot(c2, wait=true, fill=true, value=1);
c1 = initc1;
c2=initc2;
MakeMesh
getAdaptMesh


c1 = initc1;
c2=initc2;

MakeMesh
getAdaptMesh


c1 = initc1;
c2=initc2;

MakeMesh
getAdaptMesh

c1 = initc1;
c2=initc2;
c1old = c1;
c2old = c2;

GetArea;

// set constraints to initial areas
A0c1 = c1Area;
A0c2 = c2Area;
A0c3 = TotalArea - A0c1 - A0c2;

cout << c1Area << "\t" << c2Area << "\t" << c3Area << endl;

real tmpgral = int2d(Th)(c1);


plot(c2, wait=true, fill=true, value=true);

int nAdapt=0;
real curt=0.0;
// // Time stepping
int counter = 0;
bool recorded;
while(curt < endsim)//(maxCFL > 1e-4)
{
    // If needed, carry out mesh adaptation, solve again, adapt again
    if( nAdapt == dref)
    {
        // if (counter < 150)
        //     ElongateMesh(curt)
        cout << "    Mesh adpt 1, ";
        MakeMesh
        getAdaptMesh
        cout << endl;
        nAdapt++;
        nAdapt = 0;
        // n=20;
    }
    ++counter;

    cout << "Time: " << curt << endl;
    // solve equations
    curt = curt+dt;
    real c1mass = int2d(Th)(c1);
    cout << "c1 mass: " << c1Area << "  with constraint: " << A0c1 << endl;

    real c2mass = int2d(Th)(c2);
    cout << "c2 mass: " << c2Area << "  with constraint: " << A0c2 << endl;

    cout << "c3 mass: " << c3Area << "  with constraint: " << A0c3 << endl;

    SolveOne;
    SolveTwo;


    MakeMesh

    plot(interfacemesh, wait=false, fill=true, value=1);


    // Prepare for the next time step
    c1old=c1;
    // c2=1-c1;
    c2old=c2;
    // rhotwoold = rhotwo;

    // plot(c1, wait=true, fill=true, value=1);
    nAdapt++;
}