load "gmsh";
load "iovtk";
load "UMFPACK64";
load "isoline";
load "Element_P3";

verbosity=0;
real PrintStep=20;
bool doPrint=true;
string foldern = "PSfiles/";
string command = "mkdir PSfiles";
if (doPrint)
    system(command);

// -------------------------------------------------------------------------------------------------------------------------------------
// Mesh and grid

real xmin =  -3;
real xmax =  3;
real ymin =  0;
real ymax =  6;

// Mesh resolution
int  n     = 4; // Number of segments per unit length
real refI  = 5.0; // Refinement factor for the interface
real mGrw  = 1.2;  // Growth rate of the mesh elements
int  dref  = 10; // Number of time-steps between mesh adaption

real boundlength = 1.;
border a0(t=0,1){x=-3+2.5*t; y=0; label=1;}
border a1(t=0,1){x=-0.5; y=t*boundlength; label=2;}
border a2(t=0,1){x=-0.5+t; y=boundlength; label=3;}
border a3(t=0,1){x=0.5; y=boundlength-t; label=4;}
border a4(t=0,1){x=0.5+2.5*t; y=0; label=5;}
border a5(t=0,1){x=3; y=6*t; label=6;}
border a6(t=0,1){x=3-6*t; y=6; label=7;}
border a7(t=0,1){x=-3; y=6-6*t; label=8;}

mesh Th = buildmesh(a0(10) + a1(10) + a2(10) + a3(10) + a4(10) + a5(10) + a6(10) + a7(10) );
// -------------------------------------------------------------------------------------------------------------------------------------
// Fields
fespace Vhfield (Th,P2,periodic=[[a5,y],[a7,y]]);//,[1,x],[3,x]]);// periodic=[[2,y],[4,y],[1,x],[3,x]]);
Vhfield phi;
Vhfield v;
Vhfield phiold;

Vhfield rho;
Vhfield rhoold;
Vhfield w;
Vhfield rhomesh;

Vhfield absdelphi;
Vhfield phiinterface;
Vhfield phibulk;
Vhfield rhointerface;
Vhfield rhooutside;

Vhfield RhoPhitoPlot;
Vhfield rhophifield;
Vhfield curvature;

Vhfield precurvatureX;
Vhfield precurvatureY;
Vhfield divprecurvature;

// -------------------------------------------------------------------------------------------------------------------------------------
// Compilation of macros
real stalkGrowthRate = 2.;

macro ElongateMesh(time)
real increase = time * stalkGrowthRate;
border a0(t=0,1){x=-3+2.5*t; y=0; label=1;}
border a1(t=0,1){x=-0.5; y=t*(boundlength+increase); label=2;}
border a2(t=0,1){x=-0.5+t; y=boundlength+increase; label=3;}
border a3(t=0,1){x=0.5; y=(boundlength+increase)-t*(boundlength+increase); label=4;}
border a4(t=0,1){x=0.5+2.5*t; y=0; label=5;}
border a5(t=0,1){x=3; y=6*t; label=6;}
border a6(t=0,1){x=3-6*t; y=6; label=7;}
border a7(t=0,1){x=-3; y=6-6*t; label=8;}
Th = buildmesh(a0(10) + a1(10) + a2(10) + a3(10) + a4(10) + a5(10) + a6(10) + a7(10) );
// EOM

// Mesh adaptation and destruction of the old mesh
macro getAdaptMesh()
Th = adaptmesh(Th,rhomesh,hmin=1.0/(n*refI),hmax=1.0/n,iso=true,ratio=mGrw,err=0.01,nbvx=4e4,periodic=[[a5,y],[a7,y]]);
v = 0;
phi = phi;
// EOM

macro RhoPhi()
RhoPhitoPlot = phi * (rho * 2 - 1);
rhomesh = RhoPhitoPlot;
// EOM
// phi*(rho - (1-rho));

// Macro for non-linear solutions
macro solvePhase()
{

    rhophifield = rho*phi;
    rhooutside = (phi < 0.8) * (sqrt(dx(rhophifield)^2 + dy(rhophifield)^2));
    rhointerface = (phi > 0.8) * (sqrt(dx(rho)^2 + dy(rho)^2));
    BalanceDifferentiation;

    precurvatureX = dx(phi) / sqrt(dx(phi)^2 + dy(phi)^2 + epseps);
    precurvatureY = dy(phi) / sqrt(dx(phi)^2 + dy(phi)^2 + epseps);
    divprecurvature = dx(precurvatureX) + dy(precurvatureY);
    curvature = sqrt(dx(phi)^2 + dy(phi)^2) * divprecurvature;

    if (counter < 20)
    {
        absdelphi = sqrt(dx(dummyphi)^2 + dy(dummyphi)^2);
        phibulk = (absdelphi < 0.1) * dummyphi;
        phiinterface = (absdelphi * dummyphi > 0.04);
        relaxphasefield;
        RelaxRhoField;
    }
    else 
    {
        phasefield;
        RhoField;
    }
    A0 = A0 + RhoDifferentiate;
    A0P = A0P;
}
// EOM

macro BalanceDifferentiation()
{
    real diffamount = RhoDifferentiate;
    real addamount = NoParamRhoAdd;
    addrate = diffamount / addamount;
}
//EOM



real phiArea=0.;
real rhoArea=0;


macro GetArea()
    phiArea = int2d(Th)(phi^2 * (3 - 2*phi));
    rhoArea = int2d(Th)(phi * rho^2 * (3 - 2*rho));
// EOM


real epsilon=0.001;     // smoothness
real gammaphi=0.;     // surface tension of phi

real eta = 0.002;             // viscosity type1
// real eta2 = 0.001;             // viscocity type2
real a = 0.5;               // Coefficient a (depracated)
real k = 0.001;               // phase width coefficient k (depracacted)
real lmda = 10;               // concentration constraint
real A0 = 3.143;              // Target value for A
real epseps = 1e-9;           // small prefactor for 1/sqrt
real dt = 0.00005;

real aP = 10;               // Coefficient a (increased need to be at 1 or 0, increase causes decreases interface length)
real kP = 0.02;               // smoothness of interface transition, decrease causes decrease in interface length
real A0P = 3.143;              // Target value for A
real diffrate = 5;//2.5;
real addrate=0;
// adhesion to surface (negative means adhesion)
real gammas=10;
// adhesion between two cell types
real gammaSL=0.0;


// Initial parameters of the drop
real dR = 0.6;  // Radius
real dRrho = 0.4;  // Radius
real dxc= 0.0;  // x coordinate
real dyc= 1.0 + 0.2;  // y coordinate, 0.2 is start above gorund
real yct= dyc; // Variable to track the y coordinate of center of mass
real xct= dxc; // -;- x coordinate -;-
real DropTh = 0.025;
// Initialise the drop

func initPhi = 0.5 * (1-tanh((max(abs(x - dxc), abs(y - dyc - 0.5)) - dR) / DropTh))// 0.5 * (1 - tanh((sqrt((x-dxc)^2 + (y-0.4-dyc)^2) - dR) / (sqrt(2) * DropTh)))
 + 0.5 * (1 - tanh((sqrt((x-dxc)^2 + (y-1.5-dyc)^2) - dRrho) / (sqrt(2) * DropTh)));


func initRho = 0.5 * (1 - tanh((sqrt((x-dxc)^2 + (y-1.5-dyc)^2) - dRrho) / (sqrt(2) * DropTh)));

// func initPhi = 0.5 * (1-tanh((abs(x - dxc) + abs(y - dyc) - dR) / sqrt(2) / DropTh));



problem relaxphasefield(phi, v, master=0, solver=sparsesolver) // , 
    = int2d(Th) (  v * (phi)/dt  )
    //+ int2d(Th) (1/eta * (v * a * phi - 3*v*a*phi*phiold + 2*v*a*phi*phiold^2))
    // + int2d(Th) (1/eta * (k * (dx(v) *dx(phi) + dy(v) * dy(phi))))
    + int2d(Th) (1/eta * (v * 0.5 * phi - v* 1.5 * phi *phiold + v*phi*phiold^2))
    + int2d(Th) (1/eta * (epsilon * (dx(v) *dx(phi) + dy(v) * dy(phi))))
    + int2d(Th) (1/eta * ( v * (12 * lmda *(phiArea-A0)*phi*(1-phiold))))
    - int2d(Th) (  v * (phiold)/dt  )
    + int1d(Th,2,3,4)(1/eta*(gammas*phi*v))
    + on(1,5,7,phi=0);
    // + on(2, 3, 4, phi=0);
    // + on(3, phi=1);

/* the below equation has the curvature term removed*/
problem phasefield(phi, v, master=0, solver=sparsesolver) // , 
    = int2d(Th) (  v * (phi)/dt  )
    + int2d(Th) (1/eta * (v * 0.5 * phi - v* 1.5 * phi *phiold + v*phi*phiold^2))
    + int2d(Th) (1/eta * (epsilon * (dx(v) *dx(phi) + dy(v) * dy(phi))))
    + int2d(Th) ( phiinterface * (1/eta * ((epsilon - gammaphi) * v * curvature)))
    + int2d(Th) (1/eta * ( v * (12 * lmda *(phiArea-A0)*phi*(1-phiold))))
    - int2d(Th) (rhooutside * addrate * v)
    - int2d(Th) (  v * (phiold)/dt  )
    + int2d(Th) (1/eta * phi * (v * aP * rho - 3*v*aP*rho*rho + 2*v*aP*rho * rho^2))
    + int2d(Th) (1/eta * phi * (kP * (dx(v) *dx(rho) + dy(v) * dy(rho))))
    + int2d(Th) (1/eta * ( v * (12 * lmda *(rhoArea-A0P)*rho*(1-rhoold))))
    + int1d(Th,2,3,4)(1/eta*(gammas*phi*v))
    + on(1,5,7,phi=0);


// func initRho = 0.5 * (1 - tanh((sqrt((x-dxc)^2 + (y-2-dyc)^2) - drrho) / (sqrt(2) * DropTh)));

func RhoDifferentiate = int2d(Th) (dt * rhointerface * diffrate );
func NoParamRhoAdd = int2d(Th) (dt * rhooutside);

// func rhochanged = int2d(Th) (dt * phibulk * diffrate * sqrt(dx(rhoold)^2 + dy(rhoold)^2));



problem RelaxRhoField(rho, w, master=0, solver=sparsesolver)
    = int2d(Th) (w * (rho)/dt )
    + int2d(Th) (1/eta * phi * (w * aP * rho - 3*w*aP*rho*rhoold + 2*w*aP*rho * rhoold^2))
    + int2d(Th) (1/eta * phi * (kP * (dx(w) *dx(rho) + dy(w) * dy(rho))))
    + int2d(Th) (1/eta * ( w * (12 * lmda *(rhoArea-A0P)*rho*(1-rhoold))))
    // + int2d(Th) (rhointerface * (1/eta * (gammaSL * (dx(rho) * dx(w) + dy(rho) * dy(w)) / sqrt(dx(rhoold)^2 + dy(rhoold)^2 + epseps))))
    - int2d(Th) ( w * (rhoold)/dt  )
    + int1d(Th,2,3,4)(1/eta*(gammas*rho*w))
    + on(1,5,7,rho=0);

problem RhoField(rho, w, master=0, solver=sparsesolver)
    = int2d(Th) (w * (rho)/dt )
    + int2d(Th) (1/eta * phi * (w * aP * rho - 3*w*aP*rho*rhoold + 2*w*aP*rho * rhoold^2))
    + int2d(Th) (1/eta * phi * (kP * (dx(w) *dx(rho) + dy(w) * dy(rho))))
    + int2d(Th) (1/eta * ( w * (12 * lmda *(rhoArea-A0P)*rho*(1-rhoold))))
    // + int2d(Th) (rhointerface * (1/eta * (gammaSL * (dx(rho) * dx(w) + dy(rho) * dy(w)) / sqrt(dx(rhoold)^2 + dy(rhoold)^2 + epseps))))
    + int2d(Th) (rhointerface * diffrate * w )
    - int2d(Th) (rhooutside * addrate * w)
    - int2d(Th) ( w * (rhoold)/dt  )
    + int1d(Th,2,3,4)(1/eta*(gammas*rho*w))
    + on(1,5,7,rho=0);



Vhfield dummyphi;
Vhfield dummyphiold;
Vhfield dummyv;
real dtau = 0.00001;

problem DummyPhaseField(dummyphi, dummyv, master=0, solver=sparsesolver) // , 
    = int2d(Th) (  dummyv * (dummyphi)/dtau  )
    //+ int2d(Th) (1/eta * (v * a * phi - 3*v*a*phi*phiold + 2*v*a*phi*phiold^2))
    // + int2d(Th) (1/eta * (k * (dx(v) *dx(phi) + dy(v) * dy(phi))))
    + int2d(Th) (1/eta * (dummyv * 0.5 * dummyphi - 1.5*dummyv*dummyphi*phiold + dummyv*dummyphi*phiold^2))
    + int2d(Th) (1/eta * (epsilon * (dx(dummyv) *dx(dummyphi) + dy(dummyv) * dy(dummyphi))))
    + int2d(Th) (1/eta * ( dummyv * (12 * lmda *(phiArea-A0)*dummyphi*(1-phiold))))
    - int2d(Th) (  dummyv * (dummyphiold)/dtau  )
    // + int2d(Th) (1/eta * dummyphi * (dummyv * aP * rho - 3*dummyv*aP*rho*rho + 2*dummyv*aP*rho * rho^2))
    // + int2d(Th) (1/eta * dummyphi * (kP * (dx(dummyv) *dx(rho) + dy(dummyv) * dy(rho))))
    // + int2d(Th) (1/eta * ( dummyv * (12 * lmda *(rhoArea-A0P)*rho*(1-rhoold))))
    + int1d(Th,2,3,4)(1/eta*(gammas*dummyphi*dummyv))
    + on(1,5,7,dummyphi=0);



// Initialisation
phi = initPhi;
rho = initRho;
RhoPhi
// Initial mesh adaptation
getAdaptMesh
// Reinitialise the function, since it has a known value, adapt mesh again
phi = initPhi;
rho = initRho;
RhoPhi
getAdaptMesh
// Reinitialise the function, since it has a known value, adapt mesh again
phi = initPhi;
rho = initRho;
RhoPhi
getAdaptMesh
// Final initialisation of the function
phi = initPhi;
rho = initRho;
RhoPhi
cout << "CURRENT AREA: " << phiArea << endl;
phiold=phi;
rhoold=rho;

GetArea
A0 = phiArea-0.1;
A0P = rhoArea;
cout << "phi area is: " << A0 << endl;
cout << "rho area is: " << A0P << endl;
// Plot initial mesh and pf distribution
//plot(t,fill=1,value=1);
plot(Th, wait=true);
//plot(u,fill=1,value=1);
// plot(phi,fill=1,value=1);
// plot(fi,fill=1,value=1);


int nAdapt=0;
real curt=0.0;
// // Time stepping
real divChck, dxdtChck = 10.0, dxOld = 0.0, dxNew;
int  NstedChck = 0;
// continue simulation until CFL condition fails
int counter = 0;
while(true)//(maxCFL > 1e-4)
{
    // If needed, carry out mesh adaptation, solve again, adapt again
    if( nAdapt == dref)
    {
        // if (counter < 150)
        //     ElongateMesh(curt)
        cout << "    Mesh adpt 1, ";
        getAdaptMesh
        cout << endl;
        nAdapt++;
        // plot(Th, wait=true);
        nAdapt = 0;
        // plot(testing, wait=true, fill=1,value=1);
    }
    ++counter;

    // if (counter % 300 == 1)
    //     plot(Th, wait=true);
    // Solve the PF equations
    curt = curt+dt;
    

    GetArea
    solvePhase
    if (counter % 20 == 0)
    {
        cout << "ct = " << curt << ", ";
        cout << "phi area: " << phiArea << "  with constraint: " << A0 << endl;
        cout << "rho area: " << rhoArea << "  with constraint: " << A0P << endl;
        cout << "Value of addition param: " << addrate << endl;
    // plot(phi,fill=1,value=1);    
    }



    // Prepare for the next time step
    phiold = phi;
    rhoold = rho;
    dxOld = dxNew;
    nAdapt++;


    if (counter % 5 == 0)
    {
        dummyphi = phi;
        dummyphiold = dummyphi;
        // dummyv = v;
        for (int d = 0; d < 3; ++d)
        {
            DummyPhaseField;
            dummyphiold = dummyphi;            
            
        }

        absdelphi = sqrt(dx(dummyphi)^2 + dy(dummyphi)^2);
        phibulk = (absdelphi < 0.3) * dummyphi;
        phiinterface = (absdelphi > 2);
        // plot(dummyphi,fill=1,value=1, wait=true);
        // plot(phiinterface,fill=1,value=1, wait=true);
    
    }
    // if (counter % 20 == 0)
    // {
    //     // plot(rhooutside, wait=true, fill=1,value=1);
    //     plot(phiinterface, wait=true, fill=1,value=1);
    // }

    Vhfield boolRhoPhitoPlot = (RhoPhitoPlot < -0.2)*RhoPhitoPlot + (RhoPhitoPlot > 0.2)*RhoPhitoPlot;

    RhoPhi
    plot(boolRhoPhitoPlot,fill=1,value=1, wait=false);

    if (counter % PrintStep == 0 && doPrint)
    {
        string outputn = foldern + "image-" + curt + ".eps";
        plot(boolRhoPhitoPlot, ps=outputn, fill=1, wait=false);
    }
    
    // if (counter % 20 == 10)
    //     plot(rhointerface,fill=1,value=1, wait=false);
    

    // Vhfield check = phi * (1 - rho);
    // plot(check,fill=1,value=1, wait=false);
    // plot(rho,fill=1,value=1, wait=true);

    // plot(Th, wait=true);
    // plot(u,fill=1,value=1);
}